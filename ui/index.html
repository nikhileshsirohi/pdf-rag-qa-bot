<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>PDF RAG QA Bot</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 24px; }
    label { font-weight: 600; }
    select, input, textarea, button { padding: 8px; margin-top: 6px; }
    textarea { width: 600px; max-width: 100%; }
    .row { margin: 12px 0; }
    .hint { color: #666; font-size: 12px; margin-top: 4px; }
    .error { color: #b00020; font-weight: 600; white-space: pre-wrap; }
    .success { color: #0b6b0b; font-weight: 600; white-space: pre-wrap; }
    button[disabled] { opacity: 0.6; cursor: not-allowed; }
    .box { padding: 10px; border: 1px solid #ddd; border-radius: 8px; width: fit-content; max-width: 100%; }
    pre { background: #f7f7f7; padding: 12px; border-radius: 8px; border: 1px solid #eee; }
  </style>
</head>
<body>

<h2>PDF RAG QA Bot</h2>

<div class="box">

  <!-- ✅ PDF UPLOAD -->
  <div class="row">
    <label>Upload PDF:</label><br/>
    <input type="file" id="pdfFile" accept="application/pdf" />
    <button id="uploadBtn" onclick="uploadPdf()" disabled>Upload & Index</button>
    <div class="hint">Upload a PDF once. It will be chunked, embedded, and added to FAISS.</div>
    <div id="uploadMsg" class="hint"></div>
  </div>

  <hr/>

  <div class="row">
    <label>Choose Model Provider:</label><br/>
    <select id="provider">
      <option value="huggingface">Hugging Face (google/flan-t5-base)</option>
      <option value="openai">OpenAI</option>
      <option value="gemini">Gemini</option>
    </select>
    <div class="hint">OpenAI/Gemini require an API key.</div>
  </div>

  <div class="row">
    <label>API Key:</label><br/>
    <input type="password" id="apiKey" placeholder="Paste API key (required for OpenAI/Gemini)" disabled />
    <div class="hint" id="apiKeyHint"></div>
  </div>

  <div class="row">
    <label>Model Name:</label><br/>
    <select id="model"></select>
    <div class="hint" id="modelHint"></div>
  </div>

  <div class="row">
    <label>Your Question:</label><br/>
    <textarea id="question" rows="5" cols="60" placeholder="Ask a question..."></textarea>
  </div>

  <div class="row">
    <button id="askBtn" onclick="askQuestion()" disabled>Ask</button>
    <span id="status" class="hint" style="margin-left:10px;"></span>
  </div>

  <div class="row">
    <div id="uiError" class="error"></div>
  </div>

</div>

<h3>Answer:</h3>
<pre id="answer"></pre>

<script>
  const API_BASE = "http://127.0.0.1:8000";

  const MODELS = {
    huggingface: [
      { value: "", label: "Default (google/flan-t5-base)" },
      { value: "google/flan-t5-base", label: "google/flan-t5-base" }
    ],
    openai: [
      { value: "gpt-4o-mini", label: "gpt-4o-mini (cheap/fast)" },
      { value: "gpt-4o", label: "gpt-4o (stronger)" }
    ],
    gemini: [
      { value: "models/gemini-flash-lite-latest", label: "models/gemini-flash-lite-latest (fastest)" },
      { value: "models/gemini-flash-latest", label: "models/gemini-flash-latest (fast)" },
      { value: "models/gemini-pro-latest", label: "models/gemini-pro-latest (stronger)" }
    ],
  };

  const providerEl = document.getElementById("provider");
  const apiKeyEl = document.getElementById("apiKey");
  const modelEl = document.getElementById("model");
  const questionEl = document.getElementById("question");
  const askBtn = document.getElementById("askBtn");
  const uiErrorEl = document.getElementById("uiError");
  const answerEl = document.getElementById("answer");
  const statusEl = document.getElementById("status");
  const apiKeyHintEl = document.getElementById("apiKeyHint");
  const modelHintEl = document.getElementById("modelHint");

  // Upload elements
  const pdfFileEl = document.getElementById("pdfFile");
  const uploadBtn = document.getElementById("uploadBtn");
  const uploadMsgEl = document.getElementById("uploadMsg");

  function requiresApiKey(provider) {
    return provider === "openai" || provider === "gemini";
  }

  function setError(msg) {
    uiErrorEl.textContent = msg || "";
  }

  function setStatus(msg) {
    statusEl.textContent = msg || "";
  }

  function setAnswer(msg) {
    answerEl.textContent = msg || "";
  }

  function setUploadMsg(msg, isError=false) {
    uploadMsgEl.className = isError ? "error" : "success";
    uploadMsgEl.textContent = msg || "";
  }

  function fillModelDropdown(provider) {
    modelEl.innerHTML = "";
    const items = MODELS[provider] || [{ value: "", label: "Default" }];

    for (const item of items) {
      const opt = document.createElement("option");
      opt.value = item.value;
      opt.textContent = item.label;
      modelEl.appendChild(opt);
    }

    if (provider === "huggingface") {
      modelHintEl.textContent = "Using local/default HF model unless your backend supports changing it.";
    } else if (provider === "openai") {
      modelHintEl.textContent = "Choose an OpenAI model. Ensure billing/access is enabled.";
    } else if (provider === "gemini") {
      modelHintEl.textContent = "Choose a Gemini model. Model IDs here match your ListModels output.";
    } else {
      modelHintEl.textContent = "";
    }
  }

  function validateForm() {
    const provider = providerEl.value;
    const question = questionEl.value.trim();
    const needsKey = requiresApiKey(provider);
    const apiKey = apiKeyEl.value.trim();

    apiKeyEl.disabled = !needsKey;
    apiKeyHintEl.textContent = needsKey ? "API key is mandatory for OpenAI/Gemini." : "";

    let valid = true;
    let msg = "";

    if (!question) {
      valid = false;
      msg = "Type a question to enable Ask.";
    } else if (needsKey && !apiKey) {
      valid = false;
      msg = "API key is mandatory for OpenAI/Gemini.";
    }

    askBtn.disabled = !valid;
    setStatus(msg);
  }

  providerEl.addEventListener("change", () => {
    setError("");
    setAnswer("");
    fillModelDropdown(providerEl.value);
    validateForm();
  });

  apiKeyEl.addEventListener("input", validateForm);
  questionEl.addEventListener("input", validateForm);

  // ✅ Upload button enabled only when a PDF file is selected
  pdfFileEl.addEventListener("change", () => {
    setUploadMsg("", false);
    const f = pdfFileEl.files?.[0];
    uploadBtn.disabled = !(f && (f.type === "application/pdf" || f.name.toLowerCase().endsWith(".pdf")));
    if (f && !f.name.toLowerCase().endsWith(".pdf")) {
      setUploadMsg("Please select a .pdf file.", true);
    }
  });

  // Initialize UI
  fillModelDropdown(providerEl.value);
  validateForm();

  async function uploadPdf() {
    setError("");
    setUploadMsg("Uploading...", false);
    uploadBtn.disabled = true;

    const file = pdfFileEl.files?.[0];
    if (!file) {
      setUploadMsg("Please choose a PDF file first.", true);
      uploadBtn.disabled = false;
      return;
    }
    if (!file.name.toLowerCase().endsWith(".pdf")) {
      setUploadMsg("Only PDF files are allowed.", true);
      uploadBtn.disabled = false;
      return;
    }

    try {
      const formData = new FormData();
      // IMPORTANT: field name must match FastAPI param name: file
      formData.append("file", file);

      const resp = await fetch(`${API_BASE}/upload-pdf`, {
        method: "POST",
        body: formData
      });

      if (!resp.ok) {
        let errText = `Upload failed (${resp.status})`;
        try {
          const errJson = await resp.json();
          if (typeof errJson.detail === "string") errText = errJson.detail;
          else if (errJson.detail) errText = JSON.stringify(errJson.detail, null, 2);
          else errText = JSON.stringify(errJson, null, 2);
        } catch (_) {
          const raw = await resp.text();
          if (raw) errText = raw;
        }
        setUploadMsg(errText, true);
        return;
      }

      const data = await resp.json();
      const msg = data.message || "PDF uploaded successfully";
      const chunks = data.chunks_added != null ? ` (chunks added: ${data.chunks_added})` : "";
      setUploadMsg(msg + chunks, false);
    } catch (e) {
      setUploadMsg("Network error: " + (e?.message || String(e)), true);
    } finally {
      // Re-enable if a valid file still selected
      const f = pdfFileEl.files?.[0];
      uploadBtn.disabled = !(f && (f.type === "application/pdf" || f.name.toLowerCase().endsWith(".pdf")));
    }
  }

  async function askQuestion() {
    setError("");
    setStatus("Sending request...");
    setAnswer("");

    const provider = providerEl.value;
    const question = questionEl.value.trim();
    const needsKey = requiresApiKey(provider);
    const apiKey = apiKeyEl.value.trim();
    const model = modelEl.value || null;

    if (!question) {
      setStatus("");
      setError("Question is required.");
      return;
    }
    if (needsKey && !apiKey) {
      setStatus("");
      setError("API key is mandatory for OpenAI/Gemini.");
      return;
    }

    askBtn.disabled = true;

    try {
      const payload = {
        question,
        provider,
        api_key: needsKey ? apiKey : null,
        model: model || null
      };

      const response = await fetch(`${API_BASE}/ask`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        let errText = `Request failed (${response.status})`;
        try {
          const errJson = await response.json();
          if (typeof errJson.detail === "string") errText = errJson.detail;
          else if (errJson.detail) errText = JSON.stringify(errJson.detail, null, 2);
          else errText = JSON.stringify(errJson, null, 2);
        } catch (_) {
          const raw = await response.text();
          if (raw) errText = raw;
        }
        setError(errText);
        setStatus("");
        return;
      }

      const data = await response.json();
      setAnswer(data.answer ?? "(No answer field returned)");
      setStatus("Done.");
    } catch (err) {
      setError("Network error: " + (err?.message || String(err)));
      setStatus("");
    } finally {
      askBtn.disabled = false;
      validateForm();
    }
  }
</script>

</body>
</html>